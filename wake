#!/usr/bin/python

from collections import defaultdict
import argparse
import importlib
import multiprocessing
import os
import settings
import shutil
import sys
import util

def load_modules():
    modules = []
    for filename in os.listdir('./modules'):
        name, ext = os.path.splitext(filename)
        if ext == '.py':
            module = load_module(name)
            print("Loaded module: " + name)
            modules.append(module)
    modules.reverse()
    return modules

def load_module(modname):
    module = importlib.import_module("modules." + modname)
    try:
        if module.is_module():
            name = module.name()
            return module
    except AttributeError:
        print("Invalid module: " + modname, file=sys.stderr)

def scan_dir(path):
    source = []
    for path, dirs, files in os.walk(path):
        source.append(path)
        for f in files:
            source.append(path + os.sep + f)
    return source

def tidy(outmap):
    expected = []
    for sfile in outmap:
        for f in outmap[sfile]:
            expected.append(f)
    actual = scan_dir(settings.outputdir)
    orphans = set(actual).difference(set(expected))
    for orphan in orphans:
        if os.path.isdir(orphan):
            shutil.rmtree(orphan)
            print("rm -r " + orphan)
        else:
            try:
                os.remove(orphan)
                print("rm " + orphan)
            except FileNotFoundError:
                pass

def check_perms(outmap):
    for sfile in outmap:
        for f in outmap[sfile]:
            util.set_perms(f)

def map_modules(sourcedir, modules):
    # Map source files to the modules that will process them
    source = scan_dir(sourcedir)
    modmap = defaultdict(list)
    reversemap = {}
    for sfile in source:
        for module in modules:
            name, ext = os.path.splitext(sfile)
            if module.wants(name, ext):
                modname = module.name()
                modmap[modname].append(sfile)
                reversemap[sfile] = module
                break
    return modmap, reversemap

def map_outputs(modules, modmap):
    # Map source files to their output file(s)
    outmap = {}
    for module in modules:
        for sfile in modmap[module.name()]:
            name, ext = os.path.splitext(sfile)
            outmap[sfile] = module.produces(name, ext)
    return outmap

def check_modifications(outmap):
    # Determine files that have been modified (or new files)
    modified = []
    for sfile in outmap:
        smod = os.path.getctime(sfile)
        for outfile in outmap[sfile]:
            if not os.path.isfile(outfile):
                modified.append(sfile)
                continue
            omod = os.path.getctime(outfile)
            if smod > omod:
                modified.append(sfile)
    return modified

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('-t', '--num-threads', nargs='?', type=int,
            default=multiprocessing.cpu_count())
    parser.add_argument('-d', '--dry-run', action='store_true', default=False)
    args = parser.parse_args()

    modules = load_modules()
    if not modules:
        print("No modules were loaded!  Exiting.", file=sys.stderr)
        exit(1)

    print("Thread pool size: " + str(args.num_threads))

    modmap, reversemap = map_modules(settings.sourcedir, modules)
    outmap = map_outputs(modules, modmap)

    modified = check_modifications(outmap)
    pool = multiprocessing.Pool(processes=args.num_threads)
    workers = []
    for sfile in modified:
        worker = pool.map_async(reversemap[sfile].process, (sfile,))
        workers.append(worker)

    for worker in workers:
        worker.wait()
        # Report errors:
        worker.get()

    print("Removing orphaned files...")
    tidy(outmap)

    print("Verifying permissions...")
    check_perms(outmap)

    print("Build complete.")

if __name__ == "__main__":
    main()
